{:user      [{:plugins [[lein-kibit "0.0.8"]
                        [lein-lein "0.1.0"]
                        [lein-oneoff "0.3.1"]
                        [lein-pprint "1.1.1"]
                        [com.gfredericks/dot-slash "0.1.0"]
                        [cider/cider-nrepl "0.7.0"]]
              :dot-slash {:vars [[clojure.repl apropos doc pst source]
                                 [com.gfredericks.debug-repl break! unbreak!]
                                 [com.gfredericks.repl add-dep dir pp bg bg-deref]]}
              :repl-options {:nrepl-middleware
                             [com.gfredericks.debug-repl/wrap-debug-repl]}
              :dependencies [[com.gfredericks/clj-usage-graph "0.1.3"]
                             [com.gfredericks/debug-repl "0.0.2"]
                             [com.gfredericks/repl-utils "0.1.20"]]
              :aliases {"dct" ["do" "clean," "test"]
                        "try" ["with-profile" "+lein-try" "try"]}}
             :nrepl-53
             :whidbey
             ;; A mechanism for adding to the :user profile outside of this
             ;; dotfiles repo; to suppress warnings about the profile not
             ;; existing, add a file containing {} to
             ;; ~/.lein/profiles.d/local-user
             :local-user]
 :whidbey {:plugins [[com.gfredericks.forks.mvxcvi/whidbey "0.3.3-p3"]]
           :puget-options {:print-color false}
           :injections [(do (require 'clojure.tools.nrepl.middleware.pr-values)
                            ;; make pr-values a noop
                            (alter-var-root #'clojure.tools.nrepl.middleware.pr-values/pr-values
                                            (constantly identity)))]}
 :lein-try {:plugins [[lein-try "0.4.1"]]}
 :bytecode  {:plugins [[lein-nodisassemble "0.1.2"]]
             :repl-options
             {:init (do
                      (use 'no.disassemble))
              :welcome (do (println "\n\nI just did (use 'no.disassemble) for you.\n\nYou're welcome."))}}
 :slim      {:jvm-opts ["-Xmx250m"]}
 ;; monkeypatching these changes until they're merged/released:
 ;; https://github.com/gfredericks/tools.nrepl/commit/6aeb632738c5bb35d83e99a87cc552936ac806c3
 ;;
 ;; Alternatively this could be made into a vanilla fork release if we
 ;; patch leiningen to make it easier to use a forked nrepl.
 :nrepl-53  {:injections
             [(do (require 'clojure.tools.nrepl.middleware)
                  (binding [*ns* (the-ns 'clojure.tools.nrepl.middleware)]
                    (eval
                     '(do
                        (defn- topologically-sort
                          [comparator stack]
                          (let [stack (vec stack)
                                vertices (range (count stack))
                                edges (for [i1 vertices
                                            i2 (range i1)
                                            :let [x (comparator (stack i1) (stack i2))]
                                            :when (not= 0 x)]
                                        (if (neg? x) [i1 i2] [i2 i1]))
                                trivial-vertices (remove (set (apply concat edges)) vertices)]
                            (loop [sorted-vertices []
                                   remaining-edges edges
                                   remaining-vertices (remove (set trivial-vertices) vertices)]
                              (if (seq remaining-vertices)
                                (let [non-initials (->> remaining-edges
                                                        (map second)
                                                        (set))
                                      next-vertex (->> remaining-vertices
                                                       (remove non-initials)
                                                       (first))]
                                  (if next-vertex
                                    (recur (conj sorted-vertices next-vertex)
                                           (remove #((set %) next-vertex) remaining-edges)
                                           (remove #{next-vertex} remaining-vertices))
                                    (let [start (first remaining-vertices)
                                          step (into {} remaining-edges)
                                          cycle (->> (iterate step start)
                                                     (rest)
                                                     (take-while (complement #{start}))
                                                     (cons start))
                                          data {:cycle (map stack cycle)}]
                                      (throw (ex-info
                                              "Unable to satisfy nrepl middleware ordering requirements!"
                                              data)))))
                                (map stack (concat sorted-vertices trivial-vertices))))))
                        (defn linearize-middleware-stack
                          [middlewares]
                          (->> middlewares
                               extend-deps
                               (topologically-sort comparator)
                               (map :implemented-by)))))))]}
 :slamhound {:dependencies [[slamhound "1.3.3"]]
             :aliases {"slamhound" ["run" "-m" "slam.hound"]}}
 :criterium {:dependencies [[criterium "0.4.3"]]
             :jvm-opts ^:replace []}}
