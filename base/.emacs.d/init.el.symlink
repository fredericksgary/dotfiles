;; package stuff
(setq package-archives
      '(("melpa-stable" . "http://stable.melpa.org/packages/")
        ("gnu" . "http://elpa.gnu.org/packages/")
        ("marmalade" . "http://marmalade-repo.org/packages/")))

(package-initialize)

(setq my-packages
  '(clojure-mode
    cider
    dash
    align-cljlet
    jabber
    markdown-mode
    multiple-cursors
    paredit
    haskell-mode
    find-file-in-project
    projectile
    idle-highlight-mode
    refheap
    ;; evil
    magit
    git-timemachine
    window-numbering
    workgroups))

(let ((refreshed nil))
  (dolist (package-name my-packages)
    (unless (package-installed-p package-name)
      (unless refreshed (package-refresh-contents))
      (setq refreshed t)
      (package-install package-name)))

  ;; special handling for org-mode which comes prepackaged with emacs but
  ;; not in a new enough version.
  ;;
  ;; Commenting this now since the package-installed-p check is always nil
  ;; for some reason (resulting in emacs needing to connect to the internet
  ;; on each startup) and I'm not sure it's needed anymore
  ;; (unless (package-installed-p 'org (version-to-list "8.2.10"))
  ;;   (unless refreshed (package-refresh-contents))
  ;;   (package-install 'org))
    )

;; for things I've included in this repo
;; (add-to-list 'load-path "~/.emacs.d/included/")

;; modes by file extension
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(require 'dash)
(require 'clojure-mode)
(require 'cider)
(require 'find-file-in-project)
(require 'paredit)
(require 'markdown-mode)
(require 'align-cljlet)
(window-numbering-mode)

;; misc

(menu-bar-mode -99)
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
(setq-default indicate-empty-lines t)
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)

;; idle-highlight
;; it highlights usages of the symbol under point
(add-hook 'prog-mode-hook 'idle-highlight-mode)

;; projectile
(add-hook 'prog-mode-hook 'projectile-mode)
(setq projectile-project-root-files-functions
      ;; reordering these so that top-down comes before bottom-up, to
      ;; support git repos with multiple leiningen projects in them,
      ;; as well as git-worktree things
      '(projectile-root-local projectile-root-top-down projectile-root-bottom-up projectile-root-top-down-recurring))

;; ffip
(global-set-key (kbd "C-x f") 'find-file-in-project)
(setq ffip-full-paths t)
(add-to-list 'ffip-prune-patterns "local")

;; line numbers
(add-hook 'find-file-hook
          (lambda ()
            ;; linum-mode is slow for very large org files
            (when (< (buffer-size) 65536)
              (linum-mode 1))))

;; See http://en.wikipedia.org/wiki/Box-drawing_character for other
;; decent separator options
(setq linum-format "%3d\u2551")

;; whitespace
(add-hook 'before-save-hook 'delete-trailing-whitespace)

(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(ido-mode 1)
(setq ido-max-directory-size 1000000)

;; Windows
(winner-mode 1)
(setq wg-prefix-key (kbd "C-c C-g"))
(require 'workgroups)
(workgroups-mode 1)
(setq wg-morph-on nil)
(setq wg-use-faces nil)
(define-key wg-map (kbd "TAB") 'wg-switch-to-previous-workgroup)

;; Put backup files in /dev/shm/emacs-backups
(shell-command "mkdir -p /dev/shm/gary-emacs-backups && chmod 700 /dev/shm/gary-emacs-backups")
(setq backup-directory-alist '(("." . "/dev/shm/gary-emacs-backups/")))


;; paredit bindings
(defun paredit-custom ()
  "paredit-mode-hook"
  (define-key paredit-mode-map (kbd "C-x z") 'paredit-splice-sexp)
  (define-key paredit-mode-map (kbd "M-)") 'paredit-forward-slurp-sexp)
  (define-key paredit-mode-map (kbd "RET") 'newline-and-indent))
(add-hook 'paredit-mode-hook 'paredit-custom)

;; multiple-cursors
(global-set-key (kbd "C-c m e") 'mc/edit-lines)
(global-set-key (kbd "C-c m a") 'mc/mark-all-like-this)
(global-set-key (kbd "C-c m n") 'mc/mark-next-like-this)
(global-set-key (kbd "C-c m p") 'mc/mark-previous-like-this)


(defun latex-custom ()
  "latex-mode-hook"
  (define-key latex-mode-map (kbd "C-c e") 'latex-insert-item))
(add-hook 'latex-mode-hook 'latex-custom)

(defun my-start-term (prefix-arg)
  (interactive "P")
  (let* ((buffer-name-base
          (-if-let (the-workgroup (wg-current-workgroup t))
              (wg-name the-workgroup)
            "default"))
         (done? nil)
         (idx 1))
    (while (not done?)
      (let ((buffer-name (if (= 1 idx)
                             (format "*terminal-%s*" buffer-name-base)
                           (format "*terminal-%s-%d*" buffer-name-base idx))))
        (-if-let (b (get-buffer buffer-name))
            (if (get-buffer-window b)
                (setq idx (+ 1 idx))
              (progn
                (setq done? t)
                (switch-to-buffer b)))
          (progn
            (setq done? t)
            (term "/bin/bash")
            (rename-buffer buffer-name)))))))

(defun switch-term-buffers-to-char-mode (&rest args)
  ;; this way I can generally assume a term buffer is in char mode
  ;; when I switch to it
  (when (string= "term-mode" major-mode)
    (term-char-mode)
    (goto-char (- (point-max) 1))))
(advice-add 'switch-to-buffer :after #'switch-term-buffers-to-char-mode)

;; Pasted from
;; http://stackoverflow.com/questions/14444265/kill-the-terminal-buffer-with-c-d
(defun term-handle-exit--close-buffer (&rest args)
  (when (null (get-buffer-process (current-buffer)))
    (insert "Press <C-d> to kill the buffer.")
    (use-local-map (let ((map (make-sparse-keymap)))
                     (define-key map (kbd "C-d")
                       (lambda ()
                         (interactive)
                         (kill-buffer (current-buffer))))
                     map))))
(advice-add 'term-handle-exit :after #'term-handle-exit--close-buffer)

(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-coj" 'org-clock-goto)
(global-set-key "\C-cr" 'rename-buffer)
(global-set-key "\C-cs" 'my-start-term)
(global-set-key "\C-cg" 'magit-status)
(global-set-key "\C-cb" 'bury-buffer)
(global-set-key "\C-cotir" 'org-table-insert-row)
(global-set-key "\C-cotic" 'org-table-insert-column)
(global-set-key "\C-cotdr" 'org-table-kill-row)
(global-set-key "\C-cotdc" 'org-table-delete-column)
(global-set-key "\C-cc" 'org-capture)
;; (global-set-key "\C-cb" 'org-iswitchb)
;; (global-set-key "\C-cl" 'org-store-link)
(setq org-highest-priority ?0)
(setq org-lowest-priority ?9)
(setq org-default-priority ?9)

;; make workgroup commands work in the terminal buffers
(defun expose-global-binding-in-term (binding)
  (define-key term-raw-map binding
    (lookup-key (current-global-map) binding)))
(add-hook 'term-load-hook
  (lambda ()
    (expose-global-binding-in-term (kbd "C-c C-g"))
    (expose-global-binding-in-term (kbd "C-c s"))

    (define-key term-raw-map (kbd "C-x") 'nil)))


;; magit!
(require 'magit)
;; commented this out since it errors in newer emacs/magit
;; (set-face-background 'magit-item-highlight "white")
(setq magit-last-seen-setup-instructions "1.4.0")

;; Haskell?
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
;;(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
;;(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)

;; JavaScript
(setq js-indent-level 2)

;; org-mode bindings
(defun org-custom ()
  "org-mode-hook"
  (org-defkey org-mode-map (kbd "RET") 'newline-and-indent)
  (org-defkey org-mode-map (kbd "C-c o e") 'org-insert-heading)
  (org-defkey org-mode-map (kbd "C-c o f") 'org-insert-subheading)
  (org-defkey org-mode-map (kbd "C-c o g") 'org-promote-subtree)
  (org-defkey org-mode-map (kbd "C-c o d") 'org-demote-subtree)
  (org-defkey org-mode-map (kbd "C-c o p") 'org-move-subtree-up)
  (org-defkey org-mode-map (kbd "C-c o n") 'org-move-subtree-down)
  (org-defkey org-mode-map (kbd "C-c o z") 'org-add-note))
(add-hook 'org-mode-hook 'org-custom)

;; so the org agenda doesn't give me this weird 3/4 window
(setq org-agenda-window-setup nil)

(setq org-log-done 'note)


;; Allows calling narrow-to-region without confirmation
(put 'narrow-to-region 'disabled nil)

;; Using beamer with org-mode;
;; Pasted and modified from
;; http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))
(add-to-list 'org-latex-classes
  '("beamer"
    "\\documentclass\[presentation\]\{beamer\}"

     ("\\section{%s}" . "\\section*{%s}")
     ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
     ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")

     ("\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}"
       "\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}")))
(require 'ox-beamer)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(add-to-list 'org-latex-packages-alist '("" "listings"))
(setq org-latex-minted-options
      '(("frame" "single")
        ("linenos" "")))
(setq org-latex-listings 'minted)

(setq org-latex-pdf-process
            '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
              "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
              "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(defcustom gfredericks-autoexport-beamer nil
  "Exports org buffer to beamer files on save.")
(add-hook 'after-save-hook
          (lambda ()
            (if gfredericks-autoexport-beamer
                (org-beamer-export-to-latex)))
          t)

(defun start-exporting-html
  ()
  (interactive)
  (add-hook 'after-save-hook (lambda () (org-html-export-to-html)) t t))


;; Don't prompt about closing buffers from emacsclient
(remove-hook 'kill-buffer-query-functions 'server-kill-buffer-query-function)

;; General editing bindings
(global-set-key (kbd "C-h") 'backward-delete-char-untabify)
(global-set-key (kbd "C-c n") (lambda () (interactive) (other-window 2)))
(global-set-key (kbd "C-c p") (lambda () (interactive) (other-window -1)))
(global-set-key (kbd "C-c h") 'enlarge-window-horizontally)
(global-set-key (kbd "C-c C-r") 'replace-string)

;; Because I've unshifted the numeric keys
;; (global-set-key (kbd "C-x !") (key-binding (kbd "C-x 1")))
;; (global-set-key (kbd "C-x @") (key-binding (kbd "C-x 2")))
;; (global-set-key (kbd "C-x #") (key-binding (kbd "C-x 3")))
;; (global-set-key (kbd "C-x $") (key-binding (kbd "C-x 4")))

;; Scrolling. Someone on the internet suggested this might be less than
;; ideal. I dunno why. Whatever.
(setq scroll-step            1
      scroll-conservatively  10000)

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(erc-modules (quote (autoaway autojoin button completion fill irccontrols list match menu move-to-prompt netsplit networks noncommands readonly ring stamp track)) t)
 '(safe-local-variable-values (quote ((encoding . utf-8)
                                      (gfredericks-autoexport-beamer . t)
                                      (org-latex-title-command)))))
;; Please stop setting me to being away
(setq erc-autoaway-idle-seconds 86400)

;;;;;;;;;;;;;
;; CLOJURE ;;
;;;;;;;;;;;;;

;; Pasted from https://github.com/mpenet/emax/blob/master/config/modes.el#L89
(defmacro defclojureface (name color desc &optional others)
  `(defface ,name '((((class color)) (:foreground ,color ,@others))) ,desc :group 'faces))

;; (defclojureface clojure-parens "DimGrey" "Clojure parens")
;; (defclojureface clojure-braces "yellow" "Clojure braces")
(defclojureface clojure-brackets "blue" "Clojure brackets")
(defclojureface clojure-keyword "#bfebbf" "Clojure keywords")
;; (defclojureface clojure-java-call "#4bcf68" "Clojure Java calls")
;; (defclojureface clojure-special "#b8bb00" "Clojure special")
;; (defclojureface clojure-double-quote "#b8bb00" "Clojure special" (:background "unspecified"))
(set-face-foreground 'font-lock-comment-face "red")
(defun tweak-clojure-syntax ()
  (dolist (x '((("#?['`]*(\\|)" . 'clojure-parens))
               (("#?\\^?{\\|}" . 'clojure-brackets))
               (("\\[\\|\\]" . 'clojure-braces))
               ((":\\w+#?" . 'clojure-keyword))
               (("#?\"" 0 'clojure-double-quote prepend))
               (("nil\\|true\\|false\\|%[1-9]?" . 'clojure-special))
               (("(\\(\\.[^ \n)]*\\|[^ \n)]+\\.\\|new\\)\\([ )\n]\\|$\\)" 1 'clojure-java-call))
               ))
    (font-lock-add-keywords nil x)))

;; Tell cider not to require clojure.repl &c on startup
(setq nrepl-repl-requires-sexp "()")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIDER MONKEYPATCH CUSTOMIZATIONS ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;; Customized in-repl output
;; (defun cider-eval-print-handler (&optional buffer)
;;   "Make a handler for evaluating and printing result in BUFFER."
;;   (nrepl-make-response-handler (or buffer (current-buffer))
;;                                (lambda (buffer value)
;;                                  (with-current-buffer buffer
;;                                    (insert
;;                                     (if (derived-mode-p 'cider-clojure-interaction-mode)
;;                                         (format "\n%s\n" value)
;;                                       (if (string-match "\n" value)
;;                                         (format "\n=>\n%s" value)
;;                                         (format " => %s" value))))))
;;                                (lambda (_buffer out)
;;                                  (cider-emit-interactive-eval-output out))
;;                                (lambda (_buffer err)
;;                                  (cider-emit-interactive-eval-err-output err))
;;                                '()))

;; ;; pretty printing
;; (defvar gfredericks-use-whidbey-pprint nil)
;; (defadvice nrepl--eval-request (after nrepl--eval-request-after)
;;   "Add the \"renderer\" option when pretty-printing."
;;   (if gfredericks-use-whidbey-pprint
;;       (setq ad-return-value
;;             (append ad-return-value
;;                     (list "renderer" "whidbey.render/render-str")))))
;; (ad-activate 'nrepl--eval-request)
;; (defadvice cider-eval-last-sexp (around cider-eval-last-sexp-around)
;;   "Pretty print with in-buffer evaluation."
;;   (let ((gfredericks-use-whidbey-pprint t))
;;     ad-do-it))
;; (ad-activate 'cider-eval-last-sexp)
;; (defadvice cider-repl--send-input (around cider-repl--send-input-around)
;;   "Pretty-print in the repl buffer."
;;   (let ((gfredericks-use-whidbey-pprint t))
;;     ad-do-it))
;; (ad-activate 'cider-repl--send-input)


;; Auto-eval on save
(defun reload-buffer-if-cider-running ()
  (interactive)
  (if (and (cider-connected-p)
           (string= "(ns " (buffer-substring-no-properties 1 5))
           (string-match "\\.clj$" (buffer-name)))
      (cider-load-buffer)))


(add-hook 'clojure-mode-hook
          (lambda () (paredit-mode +1)
                     (tweak-clojure-syntax)
                     (show-paren-mode +1)
                     (add-hook 'after-save-hook 'reload-buffer-if-cider-running nil 'make-local)
                     (define-key clojure-mode-map (kbd "C-c C-a") 'align-cljlet)))

;; rebinding these two from C-c C-z since C-z is captured by my tmux
(add-hook 'cider-repl-mode-hook
          (lambda () (define-key cider-repl-mode-map (kbd "C-c C-y") 'cider-switch-to-last-clojure-buffer)))
(add-hook 'cider-mode-hook
          (lambda () (define-key cider-mode-map (kbd "C-c C-y") 'cider-switch-to-repl-buffer)))

(dolist (macro '(fresh conde run run* for-all for-map go go-loop
                 for> doseq> fn> defn> defprotocol> gen-for fnk
                 macrolet bg letfn> domonad checking))
  (put-clojure-indent macro 'defun))


;; java

(add-hook 'java-mode-hook (lambda ()
          (setq c-basic-offset 2)))

;; Load any ~/.emacs.d/init.*.el files
(dolist (file (directory-files user-emacs-directory
                               nil
                               "^init\\..*\\.el"))
  (load (concat user-emacs-directory file)))

;; Evil Mode
;; (global-set-key (kbd "C-c e") 'evil-mode) ; easy toggle


;; XML we all like XML right
;;
;; Pasted this from
;; http://stackoverflow.com/questions/12492/pretty-printing-xml-files-on-emacs
(defun bf-pretty-print-xml-region (begin end)
  "Pretty format XML markup in region. You need to have nxml-mode
http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
this.  The function inserts linebreaks to separate tags that have
nothing but whitespace between them.  It then indents the markup
by using nxml's indentation rules."
  (interactive "r")
  (save-excursion
      (nxml-mode)
      (goto-char begin)
      (while (search-forward-regexp "\>[ \\t]*\<" nil t)
        (backward-char) (insert "\n"))
      (indent-region begin end))
    (message "Ah, much better!"))

;;
;; Advanced workgroups stuff
;;
;; The point of this code is to support sharing workgroup working
;; configs across a series of emacsclient sessions; the assumption is
;; that before calling `emacsclient` you first kill the previous
;; client, and then call (restore-longrunning-workgroup-setup) which
;; should restore all the wconfigs from the killed client as well as
;; switch to the workgroup it was on.
;;

(defvar wconfigs-by-frame
  (make-hash-table))

(defvar during-switching? nil)

(defun my-puthash-nested (k1 k2 v ht)
  (unless (gethash k1 ht)
    (puthash k1 (make-hash-table) ht))
  (puthash k2 v (gethash k1 ht)))

(defun stash-my-working-config ()
  (interactive)
  (unless during-switching?
    (-when-let (the-workgroup (wg-current-workgroup t))
      (let ((the-wg-name (wg-name the-workgroup)))
        (my-puthash-nested (selected-frame)
                           the-wg-name
                           (wg-make-wconfig)
                           wconfigs-by-frame)))))

(add-hook 'window-configuration-change-hook
          'stash-my-working-config)

(defvar last-deleted-frame-wconfigs nil)

(defun my-frame-deletion-handler (frame)
  (setq last-deleted-frame-wconfigs
        (gethash frame wconfigs-by-frame))
  (remhash frame wconfigs-by-frame))

(add-hook 'delete-frame-functions 'my-frame-deletion-handler)

(defun restore-last-deleted-frame-wconfigs ()
  (interactive)
  (when last-deleted-frame-wconfigs
    (dolist (workgroup (wg-list t))
      (-when-let (wconfig (gethash (wg-name workgroup) last-deleted-frame-wconfigs))
        (wg-set-working-config workgroup wconfig)
        (my-puthash-nested (selected-frame)
                           (wg-name workgroup)
                           wconfig
                           wconfigs-by-frame)))))

(defun do-not-stash-while-switching-workgroups (old-fn &rest args)
  (setq during-switching? t)
  (apply old-fn args)
  (setq during-switching? nil))

(advice-add 'wg-switch-to-workgroup :around 'do-not-stash-while-switching-workgroups)

(defvar last-workgroup nil)

(defun store-workgroup (workgroup &optional _)
  (setq last-workgroup (wg-name workgroup)))

(advice-add 'wg-switch-to-workgroup :after 'store-workgroup)

(defun switch-to-last-workgroup ()
  (dolist (workgroup (wg-list t))
    (when (eq (wg-name workgroup) last-workgroup)
      (wg-switch-to-workgroup workgroup))))

(defun restore-longrunning-workgroup-setup ()
  (restore-last-deleted-frame-wconfigs)
  (switch-to-last-workgroup))

;;
;; Trying to make up for not getting alerted about new ERC messages
;; when there aren't any clients connected
;;

(defun joined-hook (&rest args)
  (let ((bname (buffer-name (current-buffer))))
    (when (not (string-match "^#" bname))
      (with-current-buffer (get-buffer-create "erc-private-messages")
        (goto-char (point-max))
        (insert (format "Message or something from \"%s\"\n" bname))))))

(add-hook 'erc-mode-hook 'joined-hook)

;;
;; Utilities for automatically setting up workgroups and stuff
;;

(defun start-terminal-with-command (buffer-name initial-command)
  (let* ((orig-buffer (current-buffer))
         (proc (get-buffer-process (term "/bin/bash"))))
    (rename-buffer buffer-name)
    (term-send-string proc (concat initial-command "\n"))
    (switch-to-buffer orig-buffer)))

;;
;; This is a good UUID:
;; c7ed5790-85d8-4b4d-a7f7-0d58f0c3b22b
;;
