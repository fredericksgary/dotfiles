#!/usr/bin/env bash

# A script for creating and managing records of where
# (presumably large) files are.
#
# Can read a directory and create a JSON file describing
# its contents (including recursing into tarballs and
# zip files), merge JSON files together, and query
# and edit JSON files

function emit-stack-trace {
    local -i x
    local -i stack_frames="${#FUNCNAME[@]}"

    {
        echo "ERROR in ${FUNCNAME[1]}() at ${BASH_SOURCE[1]}:${BASH_LINENO[0]}"

        for (( x=2; x < stack_frames; x++ ))
        do
            echo "    called by ${FUNCNAME[x]}() at ${BASH_SOURCE[x]}:${BASH_LINENO[x - 1]}"
        done
    } >&2
}

function be-strict {
    set -o errexit    # Die on non-0 exit codes other than inside conditions.
    set -o noclobber  # Do not overwrite files without being explicit about it.
    set -o nounset    # Do not allow using unset variables.
    set -o pipefail   # Cause errors in the middle of pipelines to be caught.
    set -o errtrace   # ERR trap works in functions, subshells, etc.

    trap emit-stack-trace ERR
}

be-strict

print_usage_and_exit(){
    cat >&2 <<EOF
    Usage:

    weesu catalog <source-id> <dirname>
      - writes a json file to stdout
    weesu merge <file1> <file2>
      - writes a json file to stdout
    weesu stale
      - reads json records from stdin and prints
        a summary of blobs that were previously
        seen at a source but not in the latest
        viewing of that source
    weesu histogram
      - reads json records from stdin and prints
        a count of what combinations of sources
        blobs appear in
EOF
    exit 1
}

# Unrolled format:
# "$SHA $SIZE $SOURCE_ID_BASE64 $PATH_BASE64 $AT"

# Converts the line format to the json format, removing any adjacent
# lines that are identical but for the final timestamp (retaining the
# latest timestamp)
rollup(){
    # Might be able to do this all in jq with foreach; no guess
    # whether that'd be faster though; it'd at least avoid moderately
    # long lines
    THIS_SHA=""
    THIS_SIZE=""
    THIS_DOUBLET=""
    THIS_AT=""
    THESE_TRIPLETS=()
    cat - <(echo LAST_LINE) \
        | while read SHA SIZE SOURCE_ID_BASE64 PATH_BASE64 AT; do
        if [[ "$SHA" == "LAST_LINE" ]]; then
            if [[ "$THIS_SHA" != "" ]]; then
                THESE_TRIPLETS+=("$(echo -n "$THIS_DOUBLET $THIS_AT" | base64 -w0)")
                echo "$THIS_SHA $THIS_SIZE $(echo "${THESE_TRIPLETS[*]}")"
            fi
        elif [[ "$SHA" == "$THIS_SHA" ]]; then
            [[ "$SIZE" == "$THIS_SIZE" ]] || \
                {
                    echo "UNEXPECTED SIZE MISMATCH: SHA=$SHA, SIZE1=$SIZE, SIZE2=$THIS_SIZE" >&2
                    exit 1
                }
            NEW_DOUBLET="$SOURCE_ID_BASE64 $PATH_BASE64"
            if [[ "$NEW_DOUBLET" == "$THIS_DOUBLET" ]]; then
                if [[ "$AT" > "$THIS_AT" ]]; then
                    THIS_AT="$AT"
                fi
            else
                THESE_TRIPLETS+=("$(echo -n "$THIS_DOUBLET $THIS_AT" | base64 -w0)")
                THIS_DOUBLET="$NEW_DOUBLET"
                THIS_AT="$AT"
            fi
        else
            if [[ "$THIS_SHA" != "" ]]; then
                THESE_TRIPLETS+=("$(echo -n "$THIS_DOUBLET $THIS_AT" | base64 -w0)")
                echo "$THIS_SHA $THIS_SIZE $(echo "${THESE_TRIPLETS[*]}")"
            fi
            THIS_SHA="$SHA"
            THIS_SIZE="$SIZE"
            THIS_DOUBLET="$SOURCE_ID_BASE64 $PATH_BASE64"
            THIS_AT="$AT"
            THESE_TRIPLETS=()
        fi
    done \
        | jq -cMR '. / " " | .[0] as $SHA | .[1] as $SIZE | .[2:] | map(@base64d | . / " " | {source_id: (.[0] | @base64d), path: (.[1] | @base64d), at:(.[2])}) | {sha256: $SHA, size: ($SIZE | tonumber), seen: .}'
}

# Converts the json format to the line format
unrollup(){
    jq -crM '. as $rec | .seen[] | "\($rec.sha256) \($rec.size) \(.source_id | @base64) \(.path | @base64) \(.at)"'
}

sort_and_rollup(){
    LC_ALL=C sort | rollup
}

# Prints unrolled lines
scan_dir(){
    local BASE_PATH="$1"
    local THE_DIR="$2"
    (
        cd "$THE_DIR"
        # Can add a -a flag to opt-in to hidden files at some point
        for FILE in *; do
            local THE_PATH="$BASE_PATH$FILE"
            if [[ -L "$FILE" ]]; then
                >&2 echo "WARNING: skipping symlink $(printf %q "$FILE")"
            elif [[ -f "$FILE" ]]; then
                if [[ -r "$FILE" ]]; then
                    local SHA="$(sha256sum < "$FILE" | cut -d ' ' -f 1)"
                    local SIZE="$(stat --format=%s -- "$FILE")"
                    echo "$SHA $SIZE $__WEESU_SOURCE_ID_BASE64__ $(echo -n "$THE_PATH" | base64 -w0) $__WEESU_TIME__"
                    # I'd like to get .zip files too, but I don't think
                    # the zip program has an easy enumeration option like
                    # tar does
                    if [[ "$FILE" == *.tgz || "$FILE" == *.tar.gz ]]; then
                        __WEESU_RECUR__=t \
                                       __WEESU_PATH__="$BASE_PATH$FILE//" \
                                       tar --to-command="$0" -zxf "$FILE"
                    fi
                else
                    >&2 echo "WARNING: skipping $(printf %q "$FILE"), which is not readable"
                fi
            elif [[ -d "$FILE" ]]; then
                if [[ -r "$FILE" && -x "$FILE" ]]; then
                    scan_dir "$BASE_PATH$FILE/" "$FILE"
                else
                    >&2 echo "WARNING: skipping directory $(printf %q "$FILE") due to insufficient permissions"
                fi
            else
                >&2 echo "WARNING: skipping $(printf %q "$FILE"), which is of unknown type"
            fi
        done
    )
}

if [[ -n "${__WEESU_RECUR__+x}" ]]; then
    # This is the portion called by tar when enumerating the
    # elements of a tarball
    #
    # Tricky stuff here -- we want to read the input two or three
    # times (once to get the SHA, once to get the size, and possibly
    # a third time if it's a tarball, to enumerate the contents), but
    # in a streaming fashion; so make a couple pipes and copy to them
    # with tee.
    PIPE=$(mktemp -u)
    mkfifo $PIPE
    exec 3<>$PIPE
    rm $PIPE

    if [[ "$TAR_FILENAME" == *.tgz || "$TAR_FILENAME" == *.tar.gz ]]; then
        PIPE=$(mktemp -u)
        mkfifo $PIPE
        (
            __WEESU_PATH__="$__WEESU_PATH__$TAR_FILENAME//" tar --to-command="$0" -zx <$PIPE
        ) &
        PID=$!
    else
        PIPE=/dev/null
    fi
    SHA="$(tee >(wc -c >&3) $PIPE | sha256sum | cut -d ' ' -f 1)"
    if [[ $PIPE != "/dev/null" ]]; then rm $PIPE; fi
    read SIZE <&3
    exec 3>&-
    if [[ -n "${PID:-}" ]]; then wait $PID; fi
    echo "$SHA $SIZE $__WEESU_SOURCE_ID_BASE64__ $(echo -n "$__WEESU_PATH__$TAR_FILENAME" | base64 -w0) $__WEESU_TIME__"
    exit 0
fi

# Like uniq, but only considers the first three "columns";
# uniq seems incapable of doing this
uniq13(){
    CURRENT_K=""
    while read A B C MORE; do
        K="$A $B $C"
        if [[ "$CURRENT_K" != "$K" ]]; then
            echo "$K $MORE"
            CURRENT_K="$K"
        fi
    done
}

if [[ "$#" -eq 0 ]]; then
    print_usage_and_exit
elif [[ "$(jq --version)" != "jq-1.6" ]]; then
    echo "weesu requires JQ version 1.6!" >&2
    exit 42
fi

CMD="$1"; shift

case "$CMD" in
    "catalog")
        if [[ "$#" -ne 2 ]]; then
            print_usage_and_exit
        fi
        export __WEESU_SOURCE_ID_BASE64__="$(echo -n "$1" | base64 -w0)"
        export __WEESU_TIME__="$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")"

        THE_DIR="$2"
        if [[ ! -d "$THE_DIR" ]]; then
            echo "$THE_DIR is not a directory!" >&2
            exit 1
        fi

        JQ_FILTER='. / " "
                   | {sha256: .[0],
                      size:   (.[1] | tonumber),
                      seen:   [{source_id: $source_id,
                                at:        $at,
                                path:      (.[2] | @base64d)}]}'
        scan_dir "${__WEESU_PATH__:-}" "$THE_DIR" | sort_and_rollup

        ;;
    "merge")
        if [[ "$#" -ne 2 ]]; then
            print_usage_and_exit
        fi
        FILE1="$1"
        FILE2="$2"
        cat <(unrollup < "$FILE1") <(unrollup < "$FILE2") | sort_and_rollup
        ;;
    "stale")
        if [[ "$#" -ne 0 ]]; then
            print_usage_and_exit
        fi
        JQ_FILTER='. as $rec
                   | .seen[]
                   | (.source_id | @base64) as $source64
                   | (.path | @base64) as $path64
                   | "\($source64) source_global null \(.at)",
                     "\($source64) blob \($rec.sha256) \(.at) \($path64)"'
        SOURCE_ID=""
        SOURCE_AT=""
        jq -rcMS "$JQ_FILTER" \
            | LC_ALL=C sort -k 1,3 -r \
            | uniq13 \
            | while read SOURCE_ID_64 LINE_TYPE X AT Y; do
                  case "$LINE_TYPE" in
                      "source_global")
                          SOURCE_ID="$(<<< "$SOURCE_ID_64" base64 -d)"
                          SOURCE_AT="$AT"
                      ;;
                      "blob")
                          BLOB_AT="$AT"
                          if [[ "$BLOB_AT" < "$SOURCE_AT" ]]; then
                              SHA="$X"
                              THE_PATH="$(<<< "$Y" base64 -d)"
                              echo "STALE BLOB (${SHA:0:10}) LAST SEEN IN $SOURCE_ID AT $BLOB_AT AT $THE_PATH, LATEST SOURCE MEASUREMENT AT $SOURCE_AT"
                          fi
                      ;;
                      *)
                          >&2 echo "ERROR: THIS IS IMPOSSIBLE: $(printf %q "$LINE_TYPE")"
                          exit 42
                      ;;
                  esac
        done
        ;;
    "histogram")
        if [[ "$#" -ne 0 ]]; then
            print_usage_and_exit
        fi
        JQ_FILTER='.seen | map(.source_id) | unique'
        jq -cMS "$JQ_FILTER" | sort | uniq -c
        ;;
    *)
        print_usage_and_exit
        ;;
esac
