NIX_FILE=/etc/profile.d/nix.sh
if [ -f "$NIX_FILE" ]
then
  source $NIX_FILE
fi

SELF=$(readlink -f $BASH_SOURCE)
MYBIN=`dirname $SELF`/bin
for FILE in `find ~/bin -maxdepth 1 -type l`; do
    if [[ -d "$FILE" ]]; then
        PATH=$FILE:$PATH
    fi
done
export PATH=~/bin:$MYBIN:$PATH
export EDITOR=edit

cdl(){ cd $1; ls; }
cdll(){ cd $1; ls -l; }
cdlla(){ cd $1; ls -la; }
alias lsl="ls -l"
alias lsa="ls -a"
alias lsla="ls -la"
alias lslh="ls -lh"
alias wcl="wc -l"
alias rgrep="grep -r"
alias today="date +%Y-%m-%d"
alias jqu="jq --unbuffered"
alias pyc="ping -c 1 yahoo.com"
alias emc="emacsclient"

# git shortcuts
alias gs="git status"
alias gl="git lg"
alias gc="git commit"
alias ga="git add"
alias gco="git checkout"
alias gd="git diff"
alias gr="git reset"
alias grh="git reset HEAD"
alias gpp="git pull && git push"
alias gpddraagp="git pull --rebase && git push"

# Navigation
function ..(){ for ((j=${1:-1},i=0;i<j;i++));do builtin cd ..;done;}
alias ...='.. 2'
alias ....='.. 3'
alias .....='.. 4'
alias ......='.. 5'
alias cd-="cd -"

# What does this even do?
export LESS="-R"

# https://twitter.com/petdance/status/964576338307936257
alias hed='head -n $(( $(tput lines) - 3 ))'
alias tal='tail -n $(( $(tput lines) - 3 ))'

mkcd(){ mkdir -p $1; cd $1; }
tmp(){ pushd `mktemp -d --tmpdir=/dev/shm`; }

# devdir should be defined somewhere else, as a script that takes a
# partial project name and prints a the full path to a project that
# is its best guess for that partial name
d(){
  if [ $# -eq 0 ]; then
    echo '`d` is not a thing'
    return 1
  fi
  CDTO=`devdir $1`
  if [[ -z "$CDTO" ]]; then
    echo "Can't find anything for: $1"
    return 1
  fi
  cd "$CDTO";
}



# Assemble ssh config from components
cat ~/.ssh/config.* > ~/.ssh/config
chmod 600 ~/.ssh/config

# Showing the runtime of the last command; adapted from
# http://jakemccrary.com/blog/2015/05/03/put-the-last-commands-run-time-in-your-bash-prompt/

IN_PROMPT=1

function timer_start {
    if [ $IN_PROMPT -eq "1" ]; then
        timer=${timer:-$SECONDS}
    fi
}

function timer_stop {
    the_seconds=$(($SECONDS - $timer))

    __last_stopped_at=$SECONDS

    # Hide results for <2sec to reduce noise
    if [[ $the_seconds > 1 ]]; then
        timer_show="`format-duration seconds $the_seconds`"
    else
        timer_show=""
    fi

    unset timer

}

function when-did-that-happen? {
  ___what=$(($SECONDS - $__last_stopped_at))
  ___elapsed=`format-duration seconds $___what`
  echo "That happened $___elapsed ago."
}

# Prompt
parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

HAS_DONE_WALCOM=0

if [ "$NO_FANCY_PROMPT" == "1" ]; then
  PS1="$ "
  PROMPT_COMMAND=
else
  trap 'timer_start' DEBUG
  PROMPT_COMMAND=__prompt_command
fi

__prompt_command() {
    local EXIT="$?"
    IN_PROMPT=0
    timer_stop
    if [[ "$EXTRA_PROMPT_COMMAND" ]]; then
        $EXTRA_PROMPT_COMMAND
    fi
    PS1=""

    local RCol='\[\e[0m\]'

    local Yellow='\[\e[0;33m\]'
    local Orange='\[\e[01;31m\]'
    local Red='\[\e[0;31m\]'
    local Gre='\[\e[0;32m\]'
    local Grey='\[\e[01;32m\]'
    local BYel='\[\e[1;33m\]'
    local BBlu='\[\e[1;34m\]'
    local LightGrey='\[\e[01;34m\]'
    local Pur='\[\e[0;35m\]'
    local Theme=$Yellow
    local CIRCLE="$Theme●$RCol"

    declare -A PROMPT_COMPONENTS

    GIT_BRANCH=$(parse_git_branch)
    if [[ "$GIT_BRANCH" ]]; then
        PROMPT_COMPONENTS["3-git-branch"]="$GIT_BRANCH"
    fi

    local JOBS=`jobs | wc -l`
    if [ $JOBS -gt "0" ]; then
        if [ $JOBS -eq "1" ]; then
            PROMPT_COMPONENTS["2-jobs"]="1 job"
        else
            PROMPT_COMPONENTS["2-jobs"]="$JOBS jobs"
        fi
    fi

    if [ $EXIT -gt "0" ]; then
        PROMPT_COMPONENTS["4-exit"]="${Red}$EXIT${RCol}"
    fi

    THE_TIMER=${timer_show}
    if [[ "$THE_TIMER" ]]; then
        PROMPT_COMPONENTS["5-timer"]="$THE_TIMER"
    fi

    local H;
    if [ ! -z "$BASH_PROMPT_HOSTNAME" ]; then
      H="$BASH_PROMPT_HOSTNAME"
    else
      H="$HOSTNAME"
    fi
    PROMPT_COMPONENTS["0-hostname"]="$H"
    THEWD="$PWD"
    [[ "$THEWD" =~ ^"$HOME"(/|$) ]] && THEWD="~${THEWD#$HOME}"
    PROMPT_COMPONENTS["1-pwd"]="$THEWD"

    if [ $SHLVL -gt 1 ]; then
      PROMPT_COMPONENTS["00-shlvl"]="$SHLVL"
    fi

    for k in "${!EXTRA_PROMPT_COMPONENTS[@]}"; do
        v="${EXTRA_PROMPT_COMPONENTS[$k]}"
        PROMPT_COMPONENTS["$k"]="$v"
    done

    unset EXTRA_PROMPT_COMPONENTS
    declare -A EXTRA_PROMPT_COMPONENTS

    local LINE2="$Theme◀$RCol"
    local KEYS=()
    while read line; do
        KEYS+=("$line")
    done <<< "$(for k in ${!PROMPT_COMPONENTS[@]}; do echo $k; done | sort)"

    local FIRST=1
    local LINE_LEN=1
    for k in "${KEYS[@]}"; do
        if [ $FIRST -eq "0" ]; then
            LINE2="$LINE2 $CIRCLE"
        else
            FIRST=0
        fi
        COMP="${PROMPT_COMPONENTS[$k]}"
        # counting the line length manually because the color codes
        # make the length of the string and the actual display length
        # different
        LINE_LEN=$(( $LINE_LEN + 3 + ${#COMP} ))
        LINE2="$LINE2 $COMP"
    done
    LINE2="$LINE2 $Theme▶ $RCol"
    local LINE3="${Theme}\$${RCol} "

    if [[ $LINE_LEN -gt $COLUMNS ]]; then
        LINE2=""
        for k in "${KEYS[@]}"; do
            COMP="${PROMPT_COMPONENTS[$k]}"
            LINE2="$LINE2$Theme◀$RCol $COMP\n"
        done
    else
        LINE2="$LINE2\n"
    fi

    local WALCOM=""
    if [ "$HAS_DONE_WALCOM" == "0" ]; then
      HAS_DONE_WALCOM=1
      WALCOM="\n${Theme}▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰\n▰                      ▰\n▰  WALCOM!!1 TO BASH!  ▰\n▰                      ▰\n▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰\n$RCol"
    fi

    PS1+="$WALCOM\n$LINE2$LINE3"
    IN_PROMPT=1
}

# See comment in the install-everything script; need to debug
# it so that this line isn't necessary
export LD_LIBRARY_PATH=~/.install-everything/gnupg/install/lib

# Make sure the crontab is correct
if [ -f ~/.bashrc ]; then
  diff ~/.crontab <(crontab -l) || echo "crontab doesn't match ~/.crontab !"
fi